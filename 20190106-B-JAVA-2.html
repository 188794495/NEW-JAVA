<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? './css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
	<style>
		.left{ text-align: left; }
	</style>
</head>
<body>
<img src="https://ptteng.github.io/PPT/img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
        <section>
            <h2>nginx</h2>
            <p>分享人：崔震</p>	
        </section>
        <section>
            <p>1.背景介绍</p>
            <p>2.知识剖析</p>
            <p>3.常见问题</p>            
            <p>4.编码实战</p>
            <p>5.扩展思考</p>
            <p>6.参考文献</p>
            <p>7.更多讨论</p>
        </section>
         <section class="stack past" style="top: 0px; display: block;" data-previous-indexv="0" hidden="" aria-hidden="true">
            <section style="top: 267px; display: block;" class="" aria-hidden="true">
                <h3>1.背景介绍</h3>
            </section>
            <section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p>Nginx (engine x) 是一个高性能的HTTP和反向代理服务，也是一个IMAP/POP3/SMTP服务。</p>
				<p>Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。</p>
				<p>其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。</p>
				<p>Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。</p>
            </section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p></p>
				<p></p>
				<p></p>
            </section>
        </section>
		<section class="stack past" style="top: 0px; display: block;" data-previous-indexv="0" hidden="" aria-hidden="true">
			<section style="top: 267px; display: block;" class="" aria-hidden="true">
				<h3>2.知识剖析</h3>
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p>1.Nginx是什么？</p>
				<p>Nginx就是反向代理服务器。</p>
				<p>首先我们先来看看什么是代理服务器，代理服务器一般是指局域网</p>
				<p>内部的机器通过代理服务发送请求到互联网上的服务器，代理服务器一般作用于客户端。比如GoAgent，FQ神器。</p>
				<p></p>
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p>2.反向代理和正向代理</p>
				<p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，</p>
				<p>并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
				<p></p>
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p>正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，</p>
				<p>客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p>
				<p>客户端才能使用正向代理。</p>
				<p></p>
				<p></p>
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p>3.负载均衡</p>
				<p>我们已经明确了所谓代理服务器的概念，那么接下来，nginx扮演了反向代理服务器的角色，</p>
				<p>它是以依据什么样的规则进行请求分发的呢？不用的项目应用场景，分发的规则是否可以控制呢？</p>
				<p>这里提到的客户端发送的、nginx反向代理服务器接收到的请求数量，就是我们说的负载量</p>
				<p>请求数量按照一定的规则进行分发到不同的服务器处理的规则，就是一种均衡规则</p>
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p>所以，将服务器接收到的请求按照规则分发的过程，称为负载均衡。</p>
				<p>负载均衡可分为软负载和硬负载，这些现在用不到了解一下就可以了。</p>
				<p>4.动静分离</p>
				<p>动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，</p>
				<p>我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。</p>
			</section>	
            <section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p>3.Nginx的特点</p>
				<p>（1）跨平台：Nginx 可以在大多数 Unix like OS编译运行，而且也有Windows的移植版本。</p>
				<p>（2）配置异常简单，非常容易上手。配置风格跟程序开发一样，神一般的配置</p>
				<p>（3）非阻塞、高并发连接：数据复制时，磁盘I/O的第一阶段是非阻塞的。官方测试能够支撑5万并发连接，在实际生产环境中跑到2～3万并发连接数</p>
				<p>（4）事件驱动：通信机制采用epoll模型，支持更大的并发连接。</p>
				<p>（5）稳定性高：用于反向代理，宕机的概率微乎其微</p>
			</section>	
            <section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p>（6）master/worker结构：一个master进程，生成一个或多个worker进程</p>
				<p>（7）内存消耗小：处理大并发的请求内存消耗非常小。在3万并发连接下，开启的10个Nginx 进程才消耗150M内存（15M*10=150M）</p>
				<p>（8）成本低廉：Nginx为开源软件，可以免费使用。而购买F5 BIG-IP、NetScaler等硬件负载均衡交换机则需要十多万至几十万人民币</p>
				<p>（9）内置的健康检查功能：如果 Nginx Proxy 后端的某台 Web 服务器宕机了，不会影响前端访问。</p>
				<p>（10）节省带宽：支持 GZIP 压缩，可以添加浏览器本地缓存的 Header 头。</p>
			</section>				
		</section>
		<section class="stack past" style="top: 0px; display: block;" data-previous-indexv="0" hidden="" aria-hidden="true">
			<section style="top: 267px; display: block;" class="" aria-hidden="true">
				<h3>3.常见问题</h3>
			</section>	
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p>怎么根据需求更好配置负载均衡</p>
				<p>1、轮询法将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。<p/>
				<p>2、随机法通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。<p/>
				<p></p>
				<p></p>
			</section>	
            <section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p>3、源地址哈希法源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</p>
				<p>4、加权轮询法不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</p>
				<p></p>
				<p></p>
			</section>	
            <section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p>5、加权随机法与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</p>
				<p>6、最小连接数法最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。<p/>
				<p><p/>
				<p></p>
				<p></p>
			</section>				
		</section>
		<section  class="stack past" style="top: 0px; display: block;" data-previous-indexv="0" hidden="" aria-hidden="true">
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<h3>4.编码实战</h3>
			</section>			
		</section>
		<section  class="stack past" style="top: 0px; display: block;" data-previous-indexv="0" hidden="" aria-hidden="true">
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<h3>5.扩展思考</h3>				
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p>nginx如何实现高并发</p>
				<p></p>
				<p></p>
				<p></p>
				<p></p>
				<p></p>
				<p></p>
				<p></p>
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p></p>
				<p></p>
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">
				<p></p>
				<p></p>
			</section>
		</section>
		<section>
			<h3>6.参考文献</h3>
			<p>https://www.zhihu.com/question/22062795</p>
			<p>https://blog.csdn.net/tsummerb/article/details/79248015</p>
		</section>
        <section>
            <h3>7.更多讨论</h3>	
        </section>
        
        <section>
            <h3>分享到此结束</h3>
            <p></p>            
        </section>
        <section class="stack past" style="top: 0px; display: block;" data-previous-indexv="0" hidden="" aria-hidden="true">
			<section style="top: 267px; display: block;" class="" aria-hidden="true">
			</section>
			<section class="future" aria-hidden="true" style="top: 198px; display: none;" hidden="">				
			</section>
		</section>

    </div>
</div>

<script src="https://ptteng.github.io/PPT/lib/reveal/js/head.min.js"></script>
<script src="https://ptteng.github.io/PPT/lib/reveal/reveal.js"></script>

<script>

    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
    // 	loop: false, // 是否循环演示
    // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
    // 	fragments: true, // 全局开启和关闭碎片。
    // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
    // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
    // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
    // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
    // }

    // 初始化幻灯片
    Reveal.initialize({
        history: true,
        dependencies: [
            { src: './plugin/markdown/marked.js' },
            { src: './plugin/markdown/markdown.js' },
            { src: './plugin/notes/notes.js', async: true },
            { src: './plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
    });
</script>
</body>
</html>
