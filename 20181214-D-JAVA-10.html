<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/lib/reveal/css/zenburn.css">
    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? 'https://ptteng.github.io/PPT/css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
</head>
<body>
<img src="https://ptteng.github.io/PPT/img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
         <section class="present" style="top: 221.5px; display: block;">
            <h2>Lambda表达式</h2>
            <p>分享人：汪天驰</p>	
        </section>
        <section hidden="" aria-hidden="true" class="future" style="top: 69px; display: block;">
            <p>1.背景介绍</p>
            <p>2.知识剖析</p>
            <p>3.常见问题</p>            
            <p>4.编码实战</p>
            <p>5.扩展思考</p>
            <p>6.参考文献</p>
            <p>7.更多讨论</p>
        </section>	       
		<section hidden="" aria-hidden="true" class="future" style="top: 267px; display: block;">
			<h3>1.背景介绍</h3>
			
		</section>	     

		<section class="future" style="top: 119px; display: none;" hidden="" aria-hidden="true">
		    
            <p style="text-align:left; ">
			Java 是一流的面向对象语言，除了部分简单数据类型，Java 中的一切都是对象，即使数组也是一种对象，每个类创建的实例也是对象。</br>
			在 Java 中定义的函数或方法不可能完全独立，也不能将方法作为参数或返回一个方法给实例。</br>
            从 Swing 开始，我们总是通过匿名类给方法传递函数功能，以下是旧版的事件监听代码：</br>
someObject.addMouseListener(new MouseAdapter() {</br>
        public void mouseClicked(MouseEvent e) {</br>
            //Event listener implementation goes here...</br>

        }</br>
    });</br>
			</p>

		</section>
			<section class="future" style="top: 119px; display: none;" hidden="" aria-hidden="true">
		    
            <p style="text-align:left; ">

在上面的例子里，为了给 Mouse 监听器添加自定义代码，我们定义了一个匿名内部类 MouseAdapter 并创建了它的对象，通过这种方式，我们将一些函数功能传给 addMouseListener 方法。</br>

简而言之，在 Java 里将普通的方法或函数像参数一样传值并不简单，为此，Java 8 增加了一个语言级的新特性，名为 Lambda 表达式。</br>
			
			</p>

		</section>
		<section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
			<h3>为什么 Java 需要 Lambda 表达式？</h3>
			<p style="text-align:left; ">
　　如果忽视注解(Annotations)、泛型(Generics)等特性，自 Java 语言诞生时起，它的变化并不大。</br>
Java 一直都致力维护其对象至上的特征，在使用过 JavaScript 之类的函数式语言之后，Java 如何强调其面向对象的本质，以及源码层的数据类型如何严格变得更加清晰可感。</br>
其实，函数对 Java 而言并不重要，在 Java 的世界里，函数无法独立存在。</br>
			<img src="http://blog.oneapm.com/content/images/2015/11/xkcd-functional-1.png">


			</p>
		</section>
		
		<section class="future" style="top: 119px; display: none;" hidden="" aria-hidden="true">
		    
            <p style="text-align:left; ">
			 在函数式编程语言中，函数是一等公民，它们可以独立存在，你可以将其赋值给一个变量，或将他们当做参数传给其他函数。</br>
			 JavaScript 是最典型的函数式编程语言。</br>
			 函数式语言提供了一种强大的功能——闭包，相比于传统的编程方法有很多优势，闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。</br>
			 Java 现在提供的最接近闭包的概念便是 Lambda 表达式，虽然闭包与 Lambda 表达式之间存在显著差别，但至少 Lambda 表达式是闭包很好的替代者。</br>
			</p>

		</section>
		<section class="future" style="top: 119px; display: none;" hidden="" aria-hidden="true">
		    
            <p style="text-align:left; ">
			 Lambda 表达式为 Java 添加了缺失的函数式编程特点，使我们能将函数当做一等公民看待。</br>
			 尽管不完全正确，我们很快就会见识到 Lambda 与闭包的不同之处，但是又无限地接近闭包。</br>
			 在支持一类函数的语言中，Lambda 表达式的类型将是函数。</br>
			 但是，在 Java 中，Lambda 表达式是对象，他们必须依附于一类特别的对象类型——函数式接口(functional interface)。</br>

		</section>
		<section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
			<h3>2.知识剖析</h3>
			<p></p>
		</section>
		
		<section class="future" style="top: 119px; display: none;" hidden="" aria-hidden="true">
		    <h3>Lambda 表达式简介</h3>
            <p style="text-align:left; ">
			 
           Lambda 表达式是一种匿名函数(对 Java 而言这并不完全正确，但现在姑且这么认为)，简单地说，它是没有声明的方法，也即没有访问修饰符、返回值声明和名字。</br>
			 

你可以将其想做一种速记，在你需要使用某个方法的地方写上它。</br>
			 
当某个方法只使用一次，而且定义很简短，使用这种速记替代之尤其有效，这样，你就不必在类中费力写声明与方法了。</br>
			 
是使得程序的整个体系结构变得非常灵活。</br>
			 

			</p>
		</section>

		<section class="future" style="top: 119px; display: none;" hidden="" aria-hidden="true">
		    
            <p style="text-align:left; ">
Java 中的 Lambda 表达式通常使用 (argument) -> (body) 语法书写，例如：</br>

(arg1, arg2...) -> { body }</br>

(type1 arg1, type2 arg2...) -> { body }</br>
以下是一些 Lambda 表达式的例子：</br>

(int a, int b) -> {  return a + b; }</br>

() -> System.out.println("Hello World");</br>

(String s) -> { System.out.println(s); }</br>

() -> 42</br>

() -> { return 3.1415 };</br>
			</p>

		</section>
		<section class="future" style="top: 119px; display: none;" hidden="" aria-hidden="true">
		    <h3>Lambda 表达式的结构</h3>
            <p style="text-align:left; ">
           
让我们了解一下 Lambda 表达式的结构。</br>

一个 Lambda 表达式可以有零个或多个参数</br>
参数的类型既可以明确声明，也可以根据上下文来推断。例如：(int a)与(a)效果相同</br>
所有参数需包含在圆括号内，参数之间用逗号相隔。例如：(a, b) 或 (int a, int b) 或 (String a, int b, float c)</br>

			</p>
		</section>
		<section class="future" style="top: 119px; display: none;" hidden="" aria-hidden="true">
		   
            <p style="text-align:left; ">
           
空圆括号代表参数集为空。例如：() -> 42</br>
当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：a -> return a*a</br>
Lambda 表达式的主体可包含零条或多条语句</br>
如果 Lambda 表达式的主体只有一条语句，花括号{}可省略。匿名函数的返回类型与该主体表达式一致</br>
如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空
</br>
			</p>
		</section>
		<section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
			<h3>3.常见问题</h3>
		</section>
		
		<section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">			
			<h3> 什么是函数式接口 </h3>
		</section>
		
		<section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">			
			<p style="text-align:left; ">
			 在 Java 中，Marker（标记）类型的接口是一种没有方法或属性声明的接口，简单地说，marker 接口是空接口。相似地，函数式接口是只包含一个抽象方法声明的接口。</br>

java.lang.Runnable 就是一种函数式接口，在 Runnable 接口中只声明了一个方法 void run()，相似地，ActionListener 接口也是一种函数式接口，我们使用匿名内部类来实例化函数式接口的对象，有了 Lambda 表达式，这一方式可以得到简化。</br>

每个 Lambda 表达式都能隐式地赋值给函数式接口，例如，我们可以通过 Lambda 表达式创建 Runnable 接口的引用。</br>

Runnable r = () -> System.out.println("hello world");</br>
当不指明函数式接口时，编译器会自动解释这种转化：</br>

new Thread(</br>
   () -> System.out.println("hello world")</br>
).start();</br>
			</p>
		</section>
		
		<section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">			
			<p style="text-align:left; ">
			因此，在上面的代码中，编译器会自动推断：根据线程类的构造函数签名 public Thread(Runnable r) { }，将该 Lambda 表达式赋给 Runnable 接口。</br>

以下是一些 Lambda 表达式及其函数式接口：</br>

Consumer<Integer>  c = (int x) -> { System.out.println(x) };</br>

BiConsumer<Integer, String> b = (Integer x, String y) -> System.out.println(x + " : " + y);</br>

Predicate<String> p = (String s) -> { s == null };</br>


}</br>
			</p>
		</section>
	<section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">			
			<p style="text-align:left; ">
			@FunctionalInterface 是 Java 8 新加入的一种接口，用于指明该接口类型声明是根据 Java 语言规范定义的函数式接口。Java 8 还声明了一些 Lambda 表达式可以使用的函数式接口，当你注释的接口不是有效的函数式接口时，可以使用 @FunctionalInterface 解决编译层面的错误。</br>

以下是一种自定义的函数式接口： @FunctionalInterface public interface WorkerInterface {</br>

   public void doSomeWork();</br>

}
			</p>
		</section>
		<section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">			
			<p style="text-align:left; ">
			
根据定义，函数式接口只能有一个抽象方法，如果你尝试添加第二个抽象方法，将抛出编译时错误。例如：</br>

@FunctionalInterface</br>
public interface WorkerInterface {</br>

    public void doSomeWork();</br>

    public void doSomeMoreWork();</br>

}</br>
错误：</br>

Unexpected @FunctionalInterface annotation </br>
    @FunctionalInterface ^ WorkerInterface is not a functional interface multiple </br>
    non-overriding abstract methods found in interface WorkerInterface 1 error</br>
			</p>
		</section>
	
		<section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
			<h3>4.编码实战</h3>   			
		</section>
		
		<section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
			<h3>5.扩展思考</h3>
			Lambda 表达式与匿名类的区别</p>
使用匿名类与 Lambda 表达式的一大区别在于关键词的使用。对于匿名类，关键词 this 解读为匿名类，而对于 Lambda 表达式，关键词 this 解读为写就 Lambda 的外部类。</br>

Lambda 表达式与匿名类的另一不同在于两者的编译方法。Java 编译器编译 Lambda 表达式并将他们转化为类里面的私有函数，它使用 Java 7 中新加的 invokedynamic 指令动态绑定该方法</br>

		</section>
		
		
		<section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
			<h3>6.参考文献</h3>
			<p>http://blog.oneapm.com/apm-tech/226.html</p>
		</section>        
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
            <h3>7.更多讨论</h3>
        </section>
        
        <section hidden="" aria-hidden="true" class="future" style="top: 330px; display: none;">
            <h4>分享到此结束</h4>
            <p>谢谢大家！</p>            
        </section>
      
      

    </div>
</div>


<script src="https://ptteng.github.io/PPT/lib/reveal/js/head.min.js"></script>
<script src="https://ptteng.github.io/PPT/lib/reveal/reveal.js"></script>

<script>
    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
    // 	loop: false, // 是否循环演示
    // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
    // 	fragments: true, // 全局开启和关闭碎片。
    // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
    // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
    // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
    // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
    // }
    // 初始化幻灯片
    Reveal.initialize({
        history: true,
        dependencies: [
            {src: '../plugin/markdown/marked.js'},
            {src: '../plugin/markdown/markdown.js'},
            {src: '../plugin/notes/notes.js', async: true},
            {
                src: '../plugin/highlight/highlight.js', async: true, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            }
        ]
    });
</script>
</body>
</html>
